/* eslint-disable @typescript-eslint/no-explicit-any */
import type { Provider } from '$plugins/Provider';
import type { Blockchain } from '$plugins/Blockchain';
import type { Transaction, TransactionResponse } from '$lib/common';
import eventManager from '$plugins/EventManager';
import ProviderFactory from '$plugins/ProviderFactory';
import BlockchainFactory from '$plugins/BlockchainFactory';
import { Signer } from '$plugins/Signer';

export class Wallet {
  private provider: Provider | null = null;
  private blockchain: Blockchain | null = null;

  constructor(private providerNames: string[], private blockchainNames: string[], private signer: Signer) {
    this.initialize();
  }

  private initialize(): void {
    if (this.providerNames.length > 0) {
      this.provider = ProviderFactory.createProvider(this.providerNames[0]);
    }
    if (this.blockchainNames.length > 0) {
      const providers = this.providerNames.map(name => ProviderFactory.createProvider(name));
      this.blockchain = BlockchainFactory.createBlockchain(this.blockchainNames[0], providers);
    }
    this.setupEventListeners();
  }

  private setupEventListeners(): void {
    eventManager.on('balanceFetched', this.onBalanceFetched.bind(this));
    eventManager.on('error', this.onError.bind(this));
    eventManager.on('providerConnected', this.onProviderConnected.bind(this));
    eventManager.on('providerSwitched', this.onProviderSwitched.bind(this));
    eventManager.on('requestMade', this.onRequestMade.bind(this));
  }

  private onProviderConnected(data: { provider: string, blockchain: string, chainId: number }): void {
    console.log(`Connected to ${data.provider} on ${data.blockchain} with chainId ${data.chainId}`);
  }

  private onBalanceFetched(data: { address: string, balance: bigint }): void {
    console.log(`Balance fetched for ${data.address}: ${data.balance.toString()}`);
  }

  private onProviderSwitched(data: {oldProvider: string, newProvider: string }): void {
    console.log(`Balance fetched for ${data.oldProvider}: ${data.newProvider}`);
  }

  private onError(data: { provider: string, method: string, error: any }): void {
    console.error(`Error in provider ${data.provider}, method ${data.method}:`, data.error);
  }

  private onRequestMade(data: {provider: string, method: string, params: any[], result: any}): void {
    console.log(`Balance fetched for ${data.provider}: ${data.method}, ${data.result}`);
  }

  // May want to add provider name to this method or randomize the provider. This is only for mainnet
  switchProvider(): void {
    if (!this.blockchain || !this.provider) {
      throw new Error('Blockchain or Provider not initialized');
    }

    const availableProviders = this.providerNames.map(name => ProviderFactory.createProvider(name))
      .filter(provider => provider.blockchains.includes(this.blockchain!.name));

    const newProvider = availableProviders.find(provider => provider !== this.provider);
    if (newProvider) {
      const chainId: number = this.provider.chainId;
      const oldProviderName: string = this.provider.name;

      this.provider = newProvider;
      this.blockchain.connect(newProvider, chainId);
      eventManager.emit('providerSwitched', { oldProvider: oldProviderName, newProvider: newProvider.name });
    }
  }

  // Provides a provider to switch to.
  switchToProvider(providerOrName: string | Provider): void {
    if (!this.blockchain) {
      throw new Error('Blockchain not initialized');
    }

    let newProvider: Provider | null | undefined = null;

    // if (typeof providerOrName === 'string') {
    //   newProvider = ProviderFactory.createProvider(providerOrName);
    // } else {
    //   newProvider = providerOrName;
    // }

    if (typeof providerOrName === 'string') {
      const availableProviders = this.providerNames.map(name => ProviderFactory.createProvider(name))
      .filter(provider => provider.blockchains.includes(this.blockchain!.name));
      if (!availableProviders) {
        throw new Error('No available providers for this blockchain');
      }
      newProvider = availableProviders.find(provider => provider !== this.provider);
      if (!newProvider) {
        newProvider = ProviderFactory.createProvider(providerOrName);
      }
    } else {
      newProvider = providerOrName;
    }

    if (!newProvider) {
      throw new Error(`Provider ${typeof providerOrName === 'string' ? providerOrName : 'unknown'} could not be created or is invalid.`);
    }

    if (!newProvider.blockchains.includes(this.blockchain.name)) {
      throw new Error(`Provider ${newProvider.name} does not support blockchain ${this.blockchain.name}`);
    }

    if (newProvider !== this.provider) {
      const chainId: number = this.provider?.chainId || this.blockchain.chainId;
      const oldProvider = this.provider;
      this.provider = newProvider;
      this.blockchain.connect(newProvider, chainId);
      eventManager.emit('providerSwitched', { oldProvider: oldProvider?.name, newProvider: newProvider.name });
    }
  }
  
  async getBalance(address: string): Promise<bigint> {
    if (!this.blockchain) {
      throw new Error('Blockchain not initialized');
    }
    return await this.blockchain.getBalance(address);  
  }

  async sendTransaction(transaction: Transaction): Promise<TransactionResponse> {
    if (!this.blockchain || !this.provider) {
      throw new Error('Blockchain or Provider not initialized');
    }

    const signedTransaction = await this.provider.signTransaction(transaction);
    return await this.blockchain.sendRawTransaction(signedTransaction);
  }

}
