// AvalancheSigner.ts
import { ethers } from 'ethers';
import type { Transaction } from '$lib/common';
import { Signer } from '$plugins/Signer';

export class AvalancheSigner extends Signer {
  private wallet: ethers.Wallet;

  constructor(privateKey: string | null) {
    super();
    if (!privateKey) {
      throw new Error('Private key not provided to signer');
    }
    this.wallet = new ethers.Wallet(privateKey as string);
  }

  async signTransaction(transaction: Transaction): Promise<string> {
    return await this.wallet.signTransaction(transaction);
  }

  async signMessage(message: string): Promise<string> {
    return await this.wallet.signMessage(message);
  }

  async verifySigner(signerAddress: string, messageToVerify: string, signature: string): Promise<boolean> {
    try {
      const value = ethers.recoverAddress(ethers.hashMessage(messageToVerify), signature) === signerAddress;
      if (value) {
        return Promise.resolve(value);      
      } else {
        return Promise.reject(value);
      }
    } catch (e) {
      console.log(e);
      return Promise.reject(e);
    }
  }

}
