/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/no-explicit-any */
// Arbitrum.ts
import type { AccountInfo, BlockTag, Deferrable, EthereumTransaction, MetaData, TransactionReceipt, TransactionRequest, TransactionResponse, YakklPrimaryAccount } from '$lib/common';
import { AbstractBlockchain } from '$plugins/Blockchain';
import type { Provider } from '$plugins/Provider';

export class Arbitrum extends AbstractBlockchain<EthereumTransaction> {
  createAccount<T>( accountToDeriveFrom: YakklPrimaryAccount | null, accountInfo: AccountInfo ): Promise<T> {
    throw new Error( 'Method not implemented.' );
  }
  estimateGas( transaction: Deferrable<TransactionRequest> ): Promise<bigint> {
    throw new Error( 'Method not implemented.' );
  }
  getFeeData(): Promise<any> {
    throw new Error( 'Method not implemented.' );
  }
  getTransactionCount( addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag> | undefined ): Promise<number> {
    throw new Error( 'Method not implemented.' );
  }
  getTransactionHistory( address: string ): Promise<any> {
    throw new Error( 'Method not implemented.' );
  }
  resolveName( name: string | Promise<string> ): Promise<string | null> {
    throw new Error( 'Method not implemented.' );
  }
  lookupAddress( address: string | Promise<string> ): Promise<string | null> {
    throw new Error( 'Method not implemented.' );
  }
  _options: MetaData | undefined;

  constructor(providers: Provider[], options: { [key: string]: MetaData } = {}, overrideAll: boolean = false) {
    super('Arbitrum', 42161, providers); // Arbitrum One Mainnet
    this.chainId = 42161; // 42170 - Nova, 421611 - testnet
    this.options = options;
    this._updateOptions(options, overrideAll);
    this._options = this.getOptions('arbitrum');
  }

  async getBalance(address: string): Promise<bigint> {
    if (!this.provider) {
      throw new Error('Provider not initialized');
    }
    return await this.provider.getBalance(address);
  }

  isAddress(address: string): boolean {
    return /^(0x)?[0-9a-fA-F]{40}$/.test(address);
  }

  async isSmartContract(address: string): Promise<boolean> {
    const code = await this.provider.getCode(address);
    return code !== '0x';
  }

  async sendTransaction(tx: any): Promise<any> {
    return this.provider.request('eth_sendTransaction', [tx]);
  }

  async sendRawTransaction(tx: string): Promise<TransactionResponse> {
    return this.provider.request('eth_sendRawTransaction', [tx]);
  }

  async getTransaction(hash: string): Promise<EthereumTransaction> {
    return this.provider.request('eth_getTransactionByHash', [hash]);
  }

  async getTransactionReceipt(hash: string): Promise<TransactionReceipt> {
    return this.provider.request('eth_getTransactionReceipt', [hash]);
  }
}
