// /* eslint-disable @typescript-eslint/no-explicit-any */
// /* eslint-disable no-debugger */
// import { ethers } from "ethers";
// import { PROVIDERS, BLOCKCHAINS, BLOCKCHAINS_NETWORKS } from '$lib/common/constants.js';
// import { Alchemy, Network, Wallet, isHex, toHex, type BlockTag, type TransactionRequest } from "alchemy-sdk";
// import { parseErrorMessageFromJSON } from "$lib/common";
// import type { Deferrable } from '@ethersproject/properties';

// export const providerObjects: Provider[] = [];
// export let currentProviderObj: Provider; //{ name: string; blockchain: string; chainId: string; provider: undefined; }; // Set this to providerObject

// // TODO: Need to refactor some of the code here to make it more generic and to allow for other providers!!!!!!

// // New provider object - ethers v6 had too many issues
// // eslint-disable-next-line prefer-const
// export type Provider = {
//   name: string;
//   blockchain: string;
//   chainId: string;
//   provider?: any;
//   privateKey?: any;
// }

// export const provider: Provider = {
//   name: "alchemy",
//   blockchain: "ethereum", // May not need it here
//   chainId: "0x1",
//   privateKey: null,
// }

// export function getProviderByIndex(index: number) {
//   try {
//     if (providerObjects && (index >= 0 && providerObjects.length < index)) {
//       currentProviderObj = providerObjects[index] as Provider;
//       return {providerObject: providerObjects[index], index: index};
//     }
//   } catch(e) {
//     console.log(e);
//     return undefined;
//   }
//   return undefined;
// }

// export function getCurrentProvider() {
//   return {providerObject: currentProviderObj, index: getProviderIndex(currentProviderObj)};
// }

// export function getProvider(providerObj: Provider) {
//   try {
//     let index = -1;
//     if (providerObj && providerObjects) {
//       const pro = providerObjects.find(providerObject => (providerObject.name === providerObj.name && providerObject.blockchain === providerObj.blockchain && providerObject.chainId === providerObj.chainId));
//       if (pro) {
//         currentProviderObj = pro;
//         index = providerObjects.indexOf(pro);
//       }
//       return {providerObject: pro, index: index};
//     }
//   } catch (e) {
//     console.log(e);
//     return undefined;    
//   }
//   return undefined;
// }


// // NOTE: This returns ONLY the index and not an object
// export function getProviderIndex(providerObj: Provider) {
//   try {
//     if (providerObj && providerObjects) {
//       return providerObjects.findIndex(providerObject => providerObject.name === providerObj.name && providerObject.blockchain === providerObj.blockchain && providerObject.chainId === providerObj.chainId);
//     }
//   } catch (e) {
//     console.log(e);
//     return -1;    
//   }
//   return -1;
// }


// // TBD - May can just use the JsonRpcProvider and pass in the correct url
// // Do this to set the initial provider and to change any of the parameters such as from testnets to mainnet
// // returns {provider, index} 
// export function setProvider(apiProvider=PROVIDERS.ALCHEMY, blockchain=BLOCKCHAINS.ETHEREUM, chainId="0x1", kval: string) {
//   try {
//     const providerObject = {
//       name: apiProvider,
//       blockchain: blockchain,
//       chainId: chainId,
//       provider: null
//     };
    
//     let providerObj;
//     let index;

//     if (!kval) {
//       throw 'Must have a valid key for the given provider.';
//     }

//     if (!isHex(chainId)) {
//       chainId = toHex(Number(chainId));//(Number(chainId: string | number).toString());
//     }

//     if (providerObjects?.length >= 1) {
//       providerObj = providerObjects.find(providerObject => providerObject.name === apiProvider && providerObject.blockchain === blockchain && providerObject.chainId === chainId && providerObject.provider);
//       if (providerObj) {
//         currentProviderObj = providerObj;
//         index = providerObjects.indexOf(providerObj);
//         return {providerObject: currentProviderObj, index: index}; // Provider has already been created
//       }
//     }

//     switch (blockchain) {
//       case BLOCKCHAINS.BITCOIN:  // These are placeholders for now except ethereum
//       case BLOCKCHAINS.SOLANA:
//       case BLOCKCHAINS.CARDANO:
//         break;
//       case BLOCKCHAINS.ETHEREUM:
//       default:
//         switch (apiProvider) {
//           case PROVIDERS.ETHERSCAN:
//             // eslint-disable-next-line no-undef
//             // providerObject.provider = new ethers.EtherscanProvider(getNetworkFromChainId(chainId: string | number), {projectId: kval});
//             break;
//           case PROVIDERS.INFURA:
//             // eslint-disable-next-line no-undef
//             // providerObject.provider = new ethers.InfuraProvider(getNetworkFromChainId(chainId: string | number), kval);  // Need a function that takes the chainId and returns the network name if using ethers
//             break;
//           case PROVIDERS.ALCHEMY:  // TODO: Need a better way! Some of the functions below are not set correctly (as far as chain)
//           default:
//               providerObject.provider = alchemyProvider(chainId) as Alchemy; // Verify provider is an Alchemy provider
//               // providerObject.provider = new ethers.AlchemyProvider(getNetworkFromChainId(chainId: string | number), kval); 
//               break;
//           }
//         break;
//     }
//     index = providerObjects.push(providerObject);
//     currentProviderObj = providerObject;
//     return {providerObject: currentProviderObj, index: index}; // TBD - index can change if we remove an object 
//   } catch(error) {
//     console.log(error);
//     return null;
//   }
// }


// // NOTE: These take the 'provider' property and not the 'providerObject'

// export async function getSignerByPrivKey(privKey: string) {
//   try {
//     return new Wallet(privKey); // Alchemy - it could be any provider or wallet
//   } catch (e) {
//     console.log(e);
//     return undefined;
//   }
// }

// //Gemini
// export async function getSignerByProvider(provider: Provider) {
//   try {
//     return provider.getSigner(); // Alchemy - it could be any provider or wallet
//   } catch (e) {
//     console.log(e);
//     return undefined;
//   }
// }

// export async function getSignerByProviderAndAddress(provider, address: string) {
//   try {
//     return provider.getSigner(address); // Alchemy - it could be any provider or wallet
//   } catch (e) {
//     console.log(e);
//     return undefined;
//   }
// }

// export async function getSignerByProviderAndIndex(provider, index: number) {
//   try {
//     return provider.getSigner(index); // Alchemy - it could be any provider or wallet
//   } catch (e) {
//     console.log(e);
//     return undefined;
//   }
// }

// export async function getSignerByProviderAndName(provider, name: string) {
//   try {
//     return provider.getSigner(name); // Alchemy - it could be any provider or wallet
//   } catch (e) {
//     console.log(e);
//     return undefined;
//   }
// }

// export async function getSignerByProviderAndPath(provider, path: string) {
//   try {
//     return provider.getSigner(path); // Alchemy - it could be any provider or wallet
//   } catch (e) {
//     console.log(e);
//     return undefined;
//   }
// }

// export async function getSignerByProviderAndMnemonic(provider, mnemonic: string) {
//   try {
//     return provider.getSigner(mnemonic); // Alchemy - it could be any provider or wallet
//   } catch (e) {
//     console.log(e);
//     return undefined;
//   }
// }

// export async function getSignerByProviderAndMnemonicAndPath(provider: string, mnemonic: string, path: string) {
//   try {
//     return provider.getSigner(mnemonic, path); // Alchemy - it could be any provider or wallet
//   } catch (e) {
//     console.log(e);
//     return undefined;
//   }
// }

// export async function getSignerByProviderAndMnemonicAndIndex(provider: string, mnemonic: string, index: number) {
//   try {
//     return provider.getSigner(mnemonic, index); // Alchemy - it could be any provider or

//   }
//   catch (e) {
//     console.log(e);
//     return undefined;
//   }
// }
// // End

// // Returns true for success and false for failure
// // export async function verifySigner(signerAddress: string, messageToVerify: string, signature: string) {
// //   try {
// //     // v6.0.0+
// //     // const value = ethers.recoverAddress(ethers.hashMessage(messageToVerify), signature) === signerAddress;
// //     const value = ethers.verifyMessage(messageToVerify, signature) === signerAddress;    
// //     if (value) {
// //       return Promise.resolve(value);      
// //     } else {
// //       return Promise.reject(value);
// //     }
// //   } catch (e) {
// //     console.log(e);
// //     return Promise.reject(e);
// //   }
// // }



// // export async function estimateGas(chainId: string | number, params: Deferrable<TransactionRequest>) {
// //   try {
// //     const provider = alchemyProvider(chainId);
// //     if (provider?.transact.estimateGas) {
// //       return await provider.transact.estimateGas(params);
// //     }
// //   } catch (e) {
// //     console.log(e);
// //     return undefined;
// //   }
// //   return undefined;
// // }

// // personal_sign
// // export async function signMessage(chainId: string | number, privateKey: string, messageToSign: string) {
// //   try {
// //     // let provider = alchemyProvider(chainId: string | number);
// //     // let prov = provider.getProvider();
// //     const wallet = new ethers.Wallet(privateKey); //, prov);
// //     const value = await wallet.signMessage(messageToSign);
// //     if (value) {
// //       return Promise.resolve(value);
// //     } else {
// //       return Promise.reject(value);
// //     }
// //   } catch (e) {
// //     console.log(e);
// //     return Promise.reject(e);
// //   }
// // }

// // Support eth_signTypedData_v3 and eth_signTypedData_v4 - The difference between the two are some of the data attributes of 'dataToSign'
// // export async function signTypedData(chainId: string | number, privateKey: string, dataToSign: any) {
// //   try {
// //     const provider = alchemyProvider(chainId);
// //     const prov = provider.getProvider();
// //     const signer = new ethers.JsonRpcSigner(privateKey); //, prov); // TODO: JsonRpcSigner may not be the correct signer to use
// //     // let wallet = new ethers.Wallet(privateKey); //, prov);
    
// //     console.log(dataToSign); // TODO: Remove this!!!!

// //     const value = await signer._signTypedData(dataToSign.domain, dataToSign.types, dataToSign.message);
// //     // const value = await ethers.utils.signTypedData_v4(dataToSign, wallet);
    
// //     if (value) {
// //       return Promise.resolve(value);
// //     } else {
// //       return Promise.reject(value);
// //     }
// //   } catch (e) {
// //     console.log(e);
// //     return Promise.reject(e);
// //   }
// // }

// // export async function getBalance(chainId: string | number, address: string) {
// //   try {
// //     const provider = alchemyProvider(chainId);
// //     if (provider?.core?.getBalance) {
// //       return await provider.core.getBalance(address, 'latest');
// //     }
// //   } catch (e) {
// //     console.log(e);
// //     return undefined;
// //   }
// //   return undefined;
// // }

// // block can be 'pending', 'latest', or block number
// // export async function getBlock(chainId: string | number, block: BlockTag) {
// //   try {
// //     const provider = alchemyProvider(chainId); // Verify provider is an Alchemy provider
// //     if (provider?.core.getBlock) {
// //       return await provider.core.getBlock(block);
// //     }
// //   } catch (e) {
// //     console.log(e);
// //     return undefined;
// //   }
// //   return undefined;
// // }

// // export async function getBlockNumber(chainId: string | number) {
// //   try {
// //     const provider = alchemyProvider(chainId);
// //     if (provider?.core.getBlockNumber) {
// //       return await provider.core.getBlockNumber();
// //     }
// //   } catch (e) {
// //     console.log(e);
// //     return undefined;
// //   }
// //   return undefined;
// // }

// // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any
// // export async function getBlockByNumber(chainId: string | number, block: any, transactions=false) {
// //   try {
// //     if (!transactions) {
// //       return await getBlock(chainId, block); 
// //     } else {
// //       const provider = alchemyProvider(chainId);
// //       return await (provider as Alchemy).core.getBlockWithTransactions(block);
// //     }
// //   } catch (e) {
// //     console.log(e);
// //     return undefined;
// //   }
// // } 

// // export async function getGasPrice(chainId: string | number) {
// //   try {
// //     const provider = alchemyProvider(chainId);
// //     const feeData = await (provider as Alchemy).core.getFeeData();
// //     if (feeData) {
// //       return feeData.gasPrice; // TBD - Change to return an object of maxFeePerGas, maxPriorityFeePerGas, and lastBaseFeePerGas OR feedata
// //     }
// //   } catch (e) {
// //     console.log(e);
// //     return null;
// //   }
// //   return null;
// // }

// // Returns FeeData (BigNumber) structure {gasPrices: nnn, lastBaseFeePerGas: nnn, maxFeePerGas: nnn, maxPriorityFeePerGas: nnn}
// // export async function getFeeData(chainId: string | number) {
// //   try {
// //     const provider = alchemyProvider(chainId);
// //     if (provider?.core.getFeeData) {
// //       return await provider.core.getFeeData();
// //     }
// //   } catch (e) {
// //     console.log(e);
// //     return null;
// //   }
// //   return undefined;
// // }

// // export async function call(chainId: string | number, tx: Deferrable<TransactionRequest>) {
// //   try {
// //     const provider = alchemyProvider(chainId);
// //     if (provider?.core.call) {
// //       return await provider.core.call(tx);
// //     }
// //   } catch (e) {
// //     console.log(e);
// //     return undefined;
// //   }
// //   return undefined;
// // }

// // Estimates the gas fee for the given transaction. It may not be 100% correct due to transactions not accounted for at the time of estimate
// // export async function estimateGas(chainId, tx) {
// //   try {
// //     let provider = alchemyProvider(chainId: string | number);
// //     if (provider?.core.estimateGas) {
// //       return await provider.core.estimateGas(tx);
// //     }
// //   } catch (e) {
// //     console.log(e);
// //     return undefined;
// //   }
// //   return undefined;
// // }

// // export async function getTransaction(chainId: string | number, hash: string) {
// //   try {
// //     const provider = alchemyProvider(chainId);
// //     if (provider?.transact.getTransaction) {
// //       return await provider.transact.getTransaction(hash);
// //     }
// //   } catch (e) {
// //     console.log(e);
// //     return undefined;
// //   }
// //   return undefined;
// // }

// // export async function getTransactionCount(chainId: string | number, address: string) {
// //   try {
// //     const provider = alchemyProvider(chainId);
// //     if (provider?.core.getTransactionCount) {
// //       return await provider.core.getTransactionCount(address);
// //     }
// //   } catch (e) {
// //     console.log(e);
// //     return undefined;
// //   }
// //   return undefined;
// // }

// // export async function getTransactionReceipt(chainId: string | number, hash: string) {
// //   try {
// //     const provider = alchemyProvider(chainId);
// //     if (provider?.core.getTransactionReceipt) {
// //       return await provider.core.getTransactionReceipt(hash);
// //     }
// //   } catch (e) {
// //     console.log(e);
// //     return undefined;
// //   }
// //   return undefined;
// // }

// // TODO: Need to make sure this or something like it works for history. As of 4/4/23 it does not work with any provider except Etherscan
// // NOTE: Only works for Etherscan!
// // export async function getHistory(chainId: string | number, address: string) {
// //   try {
// //     const provider = alchemyProvider(chainId);
// //       // eslint-disable-next-line @typescript-eslint/ban-ts-comment
// //     //@ts-ignore
// //     if (provider?.getHistory) {
// //       // eslint-disable-next-line @typescript-eslint/ban-ts-comment
// //       //@ts-ignore
// //       return await provider.getHistory(address);
// //     }
// //   } catch (e) {
// //     console.log(e);
// //     return undefined;
// //   }
// //   return undefined;
// // }


// // export async function isAddress(address: string) {
// //   try {
// //     const ethereumRegex = /^(0x)?[0-9a-fA-F]{40}$/; //|^.*\.eth$/;
// //     let returnValue = ethereumRegex.test(address);
// //     if (!returnValue) {
// //       const ensRegex = /^.*\.eth$/;
// //       returnValue = ensRegex.test(address);
// //     }
// //     return returnValue;
// //   } catch (e) {
// //     console.log(e);
// //     return false;
// //   }
// // }


// // export async function resolveName(chainId: string | number, address: string) {
// //   try {
// //     const provider = alchemyProvider(chainId);
// //     // eslint-disable-next-line @typescript-eslint/ban-ts-comment
// //     //@ts-ignore
// //     await provider.core.resolveName(address).then(result => {
// //       return result;
// //     // eslint-disable-next-line @typescript-eslint/no-unused-vars
// //     }).catch(e => {
// //       return null;
// //     }); 
// //   } catch (e) {
// //     console.log(e);
// //     return null;
// //   }
// // }


// // Determines if a contract is a smart contract or an EOA (normal eth address/account)
// // export async function isSmartContractAddress(chainId: string | number, address: string) {
// //   try {
// //     let contractCode;
// //     const provider = alchemyProvider(chainId);
// //     try {
// //       // eslint-disable-next-line @typescript-eslint/ban-ts-comment
// //       //@ts-ignore
// //       contractCode = await provider.core.getCode(address);
// //     } catch (e) {
// //       contractCode = null; // Don't want to return any code if there is an error
// //     }
// //     const isSmartContractAddress =
// //       contractCode && contractCode !== '0x' && contractCode !== '0x0';  
// //     return isSmartContractAddress === null ? false : isSmartContractAddress;
// //   } catch (e) {
// //     console.log(e);
// //     return false;
// //   }
// // }


// // Alchemy
// // 'transaction' param MUST have the transaction complete with most of the data in hex except for 'type' and maybe something else
// // eslint-disable-next-line @typescript-eslint/no-explicit-any
// // export async function sendTransaction(chainId: string | number, transaction: any) {
// //   try {
// //     const provider = alchemyProvider(chainId); // TODO: Need to have more generic function instead of 'alchemy' - Verify provider is an Alchemy provider
// //     const wallet = new Wallet(transaction.privateKey);
// //     delete transaction.privateKey; // Remove the private key from the transaction object
    
// //     if (transaction.nonce < 0) {
// //       transaction.nonce = await getTransactionCount(chainId, transaction.from);
// //     }

// //     const rawTransaction = await wallet.signTransaction(transaction);
// //     // eslint-disable-next-line @typescript-eslint/ban-ts-comment
// //     //@ts-ignore
// //     return await provider.transact.sendTransaction(rawTransaction);
// //   } catch (e) {
// //     throw parseErrorMessageFromJSON(JSON.stringify(e)); // This will parse the error message and return the error message that is usable
// //   }
// // }


// export function getNetworkFromChainId(chainId: string | number) {
//   let network = BLOCKCHAINS_NETWORKS.ETHEREUM.mainnet; // Default to mainnet
//   switch(chainId) {
//     // case "0x5": // Ethereum Goerli
//     // case "0x05":
//     // case 5:
//     //   network = BLOCKCHAINS_NETWORKS.ETHEREUM.goerli;
//     //   break;
//     case "0xaa36a7": // Ethereum Sepolia
//     case 11155111:
//       network = BLOCKCHAINS_NETWORKS.ETHEREUM.sepolia;
//       break;
//     case "0x1": // Ethereum mainnet
//     case "0x01":
//     case 1:
//     default:
//       network = BLOCKCHAINS_NETWORKS.ETHEREUM.mainnet;
//       break;
//   }
//   return network  
// }


// /************************************/
// // Non export functions...
// // eslint-disable-next-line @typescript-eslint/no-unused-vars
// function alchemyProvider(chainId: string | number, kval=undefined) {
//   try {
//     const config = getAlchemyConfig(chainId, kval);
//     return new Alchemy(config);
//   } catch (e) {
//     console.log(e);
//     return undefined;
//   }
// }

// // chainId must be hex
// function getAlchemyConfig(chainId: string | number, kval=undefined) {
//   try {
//     let api = kval ?? import.meta.env.VITE_ALCHEMY_API_KEY_ETHEREUM_PROD;  // Set defaults
//     let network = Network.ETH_SEPOLIA;
//     switch(chainId) {
//       // case "0x5": // Ethereum Goerli
//       // case "0x05":
//       // case 5:
//       //   api = kval ?? import.meta.env.VITE_ALCHEMY_API_KEY_ETHEREUM_PROD;
//       //   network = Network.ETH_GOERLI;
//       //   break;
//       case "0xaa36a7": // Ethereum Sepolia
//       case 11155111:
//         api = kval ?? import.meta.env.VITE_ALCHEMY_API_KEY_ETHEREUM_PROD;
//         network = Network.ETH_SEPOLIA;
//         break;
//       case "0x1": // Ethereum mainnet
//       case "0x01":
//       case 1:
//       default:
//         api = kval ?? import.meta.env.VITE_ALCHEMY_API_KEY_ETHEREUM_PROD;
//         network = Network.ETH_MAINNET;
//         break;
//     }
//     return {
//       apiKey: api, 
//       network: network, 
//     }
//   } catch (e) {
//     console.log(e);
//     return undefined;
//   }
// }


