chrome.runtime.onConnect.addListener((port) => {
  if (port.name === 'YAKKL_PORT') {
    port.onMessage.addListener(async (message) => {
      if (message.type === 'YAKKL_REQUEST') {
        const { id, method, params } = message;

        // Add handling for `eth_chainId`
        if (method === 'eth_chainId') {
          // If a chainId is provided, switch to the requested chain
          if (params && params.length > 0 && params[0]) {
            const newChainId = params[0];
            const isValidChainId = await validateChainId(newChainId);
            if (isValidChainId) {
              await switchToChain(newChainId);
              const currentChainId = await getCurrentChainId();
              port.postMessage({ id, result: currentChainId, type: 'YAKKL_RESPONSE' });
            } else {
              port.postMessage({ id, error: 'Invalid chainId', type: 'YAKKL_RESPONSE' });
            }
          } else {
            const currentChainId = await getCurrentChainId();
            port.postMessage({ id, result: currentChainId, type: 'YAKKL_RESPONSE' });
          }
        }
        // ... handle other methods
      }
    });
  }
});

// ... other code


// For signing and sending transactions

import { ethers } from 'ethers';

// ...

chrome.runtime.onConnect.addListener((port) => {
  if (port.name === 'YAKKL_PORT') {
    port.onMessage.addListener(async (message) => {
      if (message.type === 'YAKKL_REQUEST') {
        const { id, method, params } = message;

        // Add handling for `eth_sign`
        if (method === 'eth_sign') {
          const [address, message] = params;
          const signer = getSignerForAddress(address);
          const signature = await signer.signMessage(ethers.utils.arrayify(message));
          port.postMessage({ id, result: signature, type: 'YAKKL_RESPONSE' });
        }
        // Add handling for `eth_sendTransaction`
        else if (method === 'eth_sendTransaction') {
          const [transaction] = params;
          const signer = getSignerForAddress(transaction.from);
          const response = await signer.sendTransaction(transaction);
          port.postMessage({ id, result: response.hash, type: 'YAKKL_RESPONSE' });
        }
        // ... handle other methods
      }
    });
  }
});

// ... other code


// For handling eth_accounts and change requests

chrome.runtime.onConnect.addListener((port) => {
  if (port.name === 'YAKKL_PORT') {
    port.onMessage.addListener(async (message) => {
      if (message.type === 'YAKKL_REQUEST') {
        // Process the request and communicate with the wallet
        const { id, method, params } = message;

        // Implement wallet-specific logic to handle different Ethereum JSON-RPC methods
        // Example: handle `eth_accounts`
        if (method === 'eth_accounts') {
          const accounts = await getConnectedAccounts();
          port.postMessage({ id, result: accounts, type: 'YAKKL_RESPONSE' });
        }
        // Handle other methods similarly
      } else if (message.type === 'YAKKL_ACCOUNTS_CHANGED') {
        // Handle the account changes event
        // Example: send the new accounts list to the content script
        const { id, accounts } = message;
        port.postMessage({ id, result: accounts, type: 'YAKKL_RESPONSE' });
      }
    });
  }
});

// Listen for account changes from the wallet and send a message to the content script
walletInstance.on('accountsChanged', (accounts: string[]) => {
  const message = { type: 'YAKKL_ACCOUNTS_CHANGED', accounts };
  port.postMessage(message); // Use port.postMessage instead of chrome.runtime.sendMessage
});




