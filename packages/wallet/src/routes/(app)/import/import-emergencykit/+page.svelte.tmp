<script>
  import { browser as browserSvelte} from '$app/environment';
  import { ethers } from 'ethers';
  import { createForm } from "svelte-forms-lib";
  import * as yup from 'yup';
  import Back from '$lib/components/Back.svelte';
  import {onMount} from 'svelte';
  import { goto } from "$app/navigation";
  import { Button, Modal } from 'flowbite-svelte';
  import { verify } from '$lib/utilities/utilities';
  import { getWallet } from '$lib/utilities/ethereum';
  // import { getTransactionCount, setProvider } from '$lib/plugins/networks/ethereum/providers';
  import { dateString, deepCopy, getSymbol } from '$lib/utilities/utilities';
  import { Confetti } from "svelte-confetti";
  import { setYakklSettingsStorage, getYakklSettings, yakklMiscStore, setYakklProfileStorage, setYakklCurrentlySelectedStorage, yakklCurrentlySelectedStore, setYakklPrimaryAccountsStorage, getYakklPrimaryAccounts, getYakklAccounts, getYakklAssets, setYakklAccountsStorage, yakklNetworksStore, getYakklNetworks } from '$lib/storage/local/stores';
  import { encryptData, decryptData } from '$lib/plugins/common/encryption';
  import { DEFAULT_DERIVED_PATH_ETH, PATH_WELCOME } from '$lib/plugins/common/constants';
  // import { Wallet } from 'alchemy-sdk';

  let error = false;
  let errorValue;
  let msgType = 'ERROR! - ';
  let showConfetti = false;
  let elements;
  let selected = '24';
  let mtop = '';
  let subAccounts = true;

  async function processSecretPhaseRecovery(data) {
    if (browserSvelte) {
      try {
        createPortfolioAccount(data.secretPhrase);
        clearData(data);
      } catch (e) {
        errorValue = e
        clearData(data);
        error = true;
      }
    }
  }



// This is the emergency kit so it needs to be able to restore everything from the encrypted data

// TODO: WIP WIP WIP WIP


  async function createPortfolioAccount(mnemonic=null) {
    try {
      if ( browserSvelte ) {
        let id=0;
        let yakklSettings;
        let yakklProfile;
        let yakklCurrentlySelected;
        let accountName = 'Portfolio Account 1';
        let ethWallet;
        let mnemonic='';
        let password;
        let preferences;
        let displayDate;
        let derivedPath = DEFAULT_DERIVED_PATH_ETH; // Account gets created with '/0/0' appended to represent the first
        let assetKey = {name: $yakklCurrentlySelectedStore.shortcuts.networkName, class: 'Token', subClass: ''};
        let asset;
        let mnemonicObject;

        // Could always pull first item from yakklAssets (should already have been loaded into storage)
        let yakklAssets = await getYakklAssets();
        if (yakklAssets) {
          asset = yakklAssets.find(item => item.name === assetKey.name && item.class === assetKey.class);
        }

        if (!asset) {
          asset = yakklAssets[0];
        }

        yakklSettings = await getYakklSettings();
        if (!yakklSettings) {
          // noop but could load the defaults. For now we will error out!
          throw 'The settings data has not been initialized. This could be due to not yet registered or data could be incomplete which requires registering again. If unable to re-register then uninstall and reinstall. No Ethereum data will be impacted.';
        }

        id = yakklSettings.id;

        // yakklProfile = await getYakklProfile();
        yakklProfile = await verify(userName.toLowerCase().trim().replace('.nfs.id', '')+'.nfs.id'+password);
        if (!yakklProfile) {
          errorValue = `User ${data.userName} was not found OR password is not correct`;
          clearData(data);
          throw errorValue;
        }

        if (!yakklProfile.data?.data || !$yakklMiscStore) {
          throw 'Profile data does not appear to be encrypted. Please register or re-register. Thank you.';
        }
            
        await decryptData(yakklProfile.data, $yakklMiscStore).then(result => {
          yakklProfile.data = result;
        });

        yakklProfile.data.meta = {};        
        preferences = yakklProfile.preferences;

        let index = yakklProfile.data.accountIndex ?? 0;
        derivedPath = `${DEFAULT_DERIVED_PATH_ETH}${index}'/0/0`;

        if (!mnemonic) {
          // Use this instead of createRandom to create 24 words instead of 12 - 32 bytes = 24 words and 16 bytes = 12 words
          let bytes = ethers.randomBytes(!preferences ? 32 : (!preferences.bytes ? 32 : preferences.bytes));
          let randomMnemonic = ethers.Mnemonic.fromEntropy(bytes);
          mnemonicObject = randomMnemonic
          ethWallet = ethers.HDNodeWallet.fromMnemonic(randomMnemonic, derivedPath); //ethers.Wallet.fromPhrase(randomMnemonic.phrase);           
        } else {
          mnemonicObject = ethers.Mnemonic.fromPhrase(mnemonic);
          ethWallet = ethers.HDNodeWallet.fromMnemonic(mnemonicObject, derivedPath);
        }

        if ( !ethWallet ) {
          throw "The Ethereum Wallet (Portfolio Account) was not able to be created. Please try again.";
        } 

        let currentDate = dateString();                          
        displayDate = new Date(currentDate);

        yakklProfile.data.accountIndex = index+1;  // PortfolioAccount index for path

        let yakklAccount = {
          id: yakklProfile.id,
          index: index,
          networkName: 'Ethereum',
          network: yakklNetworks.find(item => item.name === 'Ethereum'),
          smartContract: false,
          address: ethWallet.address,
          alias: '',
          accountType: 'primary',
          name: !accountName ? `Top Level Account ${index+1}` : accountName,
          description: '',
          assetKey: assetKey,
          primaryAccount: '',  // If subaccount then it must be a valid primaryaccount else undefined
          data: {
            extendedKey: ethWallet.extendedKey,
            privateKey: ethWallet.privateKey,
            publicKey: ethWallet.publicKey,
            publicKeyUncompressed: ethWallet.signingKey.publicKey,
            path: ethWallet.path ? ethWallet.path : derivedPath,     
            pathIndex: index,
            fingerPrint: ethWallet.fingerprint,
            parentFingerPrint: ethWallet.parentFingerprint,
            chainCode: ethWallet.chainCode,
            assignedTo: [],    // Who are the parties that have responsibility for this account
          },
          value: '0.0', 
          class: "Default",  // This is only used for enterprise like environments. It can be used for departments like 'Finance', 'Accounting', '<whatever>'
          level: 'L1',
          isSigner: true,
          avatar: '', // Default is identityicon but can be changed to user/account avatar
          tags: [$yakklCurrentlySelectedStore.shortcuts.networkName, 'primary'],
          includeInPortfolio: true,   // This only applys to the value in this primary account and not any of the derived accounts from this primary account
          urlExplorer: "https://etherscan.io/address/" + ethWallet.address,
          connectedDomains: [], 
          createDate: currentDate,
          updateDate: currentDate,
        };

        let yakklPrimaryAccount = {
          id: yakklAccount.id,
          name: yakklAccount.name,
          address: yakklAccount.address,
          value: yakklAccount.value,
          index: index,  // for the primary account path index
          data: {
            privateKey: ethWallet.privateKey,
            publicKey: ethWallet.publicKey,
            path: ethWallet.path ? ethWallet.path : derivedPath,
            pathIndex: index,
            fingerPrint: ethWallet.fingerprint,
            parentFingerPrint: ethWallet.parentFingerprint,
            chainCode: ethWallet.chainCode,
            extendedKey: ethWallet.extendedKey,
            mnemonicObject: ethWallet.mnemonic,
            mnemonic: ethWallet.mnemonic.phrase,
            entropy: ethWallet.mnemonic.entropy,
            password: ethWallet.mnemonic.password,
            publicKeyUncompressed: ethWallet.signingKey.publicKey,
            wordCount: ethWallet.mnemonic.phrase.split(" ").length,
            wordListLocale: ethWallet.mnemonic.wordlist.locale,
          },
          account: yakklAccount,  // yakklAccount.primaryAccount is always undefined here since it is the primary account
          subIndex: 0,  // for the subaccount derived path index
          subAccounts: [], // Always empty since the primary account is the start of the tree
          createDate: yakklAccount.createDate,
          updateDate: yakklAccount.updateDate,
        }

        let yakklPrimaryAccountEnc = deepCopy(yakklPrimaryAccount);

        await encryptData(yakklPrimaryAccount.data, $yakklMiscStore).then(result => {
          yakklPrimaryAccountEnc.data = result;
        });

        yakklPrimaryAccountEnc.account = yakklAccount;
        
        await encryptData(yakklAccount.data, $yakklMiscStore).then(result => {
          yakklPrimaryAccountEnc.account.data = result;
        });

        let yakklPrimaryAccounts = [];
        let primaryAccountsStorage = await getYakklPrimaryAccounts();
        
        if (primaryAccountsStorage?.length > 0) {
          yakklPrimaryAccounts = primaryAccountsStorage;
        }

        if (yakklPrimaryAccountEnc) {
          yakklPrimaryAccounts.push(yakklPrimaryAccountEnc);
          // yakklPrimaryAccounts = [...yakklPrimaryAccountEnc, yakklPrimaryAccounts.length + 1]; // This version causes reactivity of any variables using '$:' syntax
          await setYakklPrimaryAccountsStorage(yakklPrimaryAccounts);
        }

        let profileIndex = yakklProfile.data.primaryAccounts.push(yakklPrimaryAccountEnc);

        let yakklAccounts = [];
        let accountsStorage = await getYakklAccounts();
      
        if (accountsStorage?.length > 0) {
          yakklAccounts = accountsStorage;
        }

        yakklPrimaryAccountEnc.account.primaryAccount = '';

        yakklAccounts.push(yakklPrimaryAccountEnc.account);
        await setYakklAccountsStorage(yakklAccounts);

        // TODO: May want to remove this
        await ethWallet.signMessage($yakklMiscStore).then(result => {
          yakklProfile.data.sig = result;
        });

        let yakklProfileEnc = deepCopy(yakklProfile); // Need deep copy...

        await encryptData(yakklProfileEnc.data, $yakklMiscStore).then(result => {
          yakklProfileEnc.data = result;
        });

        if (yakklProfileEnc) {
          await setYakklProfileStorage(yakklProfileEnc);
          yakklSettings.init = $yakklCurrentlySelectedStore.shortcuts.init = true;
          yakklSettings.isLocked = $yakklCurrentlySelectedStore.shortcuts.isLocked = false;
          await setYakklSettingsStorage(yakklSettings);

          accountName = yakklAccount.name;

          $yakklCurrentlySelectedStore.network = yakklAccount.network;
          yakklCurrentlySelected = $yakklCurrentlySelectedStore; // This store needs to have been initialized for the first use and then kept updated from there

          yakklCurrentlySelected.id = yakklProfile.id;
          yakklCurrentlySelected.preferences.locale = preferences.locale;
          yakklCurrentlySelected.preferences.currency = preferences.currency;

          yakklCurrentlySelected.shortcuts.networkName = yakklAccount.networkName;
          yakklCurrentlySelected.shortcuts.networkSymbol = getSymbol(yakklAccount.networkName);
          yakklCurrentlySelected.shortcuts.isLocked = false;
          yakklCurrentlySelected.shortcuts.showTestNetworks = preferences.showTestNetworks;
          yakklCurrentlySelected.shortcuts.profile.name = yakklProfile.data.name.first+":"+yakklProfile.data.name.last;
          yakklCurrentlySelected.shortcuts.profile.email = yakklProfile.data.email;
          yakklCurrentlySelected.shortcuts.primary = yakklCurrentlySelected.shortcuts.address = yakklPrimaryAccountEnc.account.address;
          yakklCurrentlySelected.shortcuts.accountName = accountName;
          yakklCurrentlySelected.shortcuts.accountType = 'primary';
          yakklCurrentlySelected.shortcuts.smartContract = false;

          yakklCurrentlySelected.data.primaryAccount = yakklPrimaryAccountEnc;
          yakklCurrentlySelected.data.account = yakklAccount;

          yakklCurrentlySelected.createDate = yakklAccount.createDate;
          yakklCurrentlySelected.updateDate = yakklAccount.updateDate;

          let currentDeepCopy = deepCopy(yakklCurrentlySelected);
          await setYakklCurrentlySelectedStorage(yakklCurrentlySelected);
          $yakklCurrentlySelectedStore = currentDeepCopy;

          // Create subAccounts if enabled
          if (subAccounts) {
            let derivedIndex = 0;
            
            while (true) {
              dPath = `${DEFAULT_DERIVED_PATH_ETH}${index}'/0/${derivedIndex}}`;
              
              const ethWallet = ethers.HDNodeWallet.fromMnemonic(mnemonicObject, dPath);
              const wallet = getWallet(ethWallet.privateKey);
              const transactionCount = await wallet.getTransactionCount();

              if (transactionCount === 0) {
                break;
              }

              let addressDerived = wallet.address;
              yakklPrimaryAccount.subIndex += 1;

                      // Get networks
              let yakklNetworks = await getYakklNetworks();
              $yakklNetworksStore = yakklNetworks;

              let yakklAccount = {
                id: yakklProfile.id,
                index: (yakklPrimaryAccount.subIndex > 0 ? yakklPrimaryAccount.subIndex-1 : 0),
                networkName: $yakklCurrentlySelectedStore.shortcuts.networkName,
                network: yakklNetworks.find(item => item.name === 'Ethereum'),
                smartContract: false,
                address: addressDerived,
                alias: '',
                accountType: 'sub',
                name:`Account ${yakklPrimaryAccount.subIndex}`,
                description: '',
                assetKey: assetKey,
                primaryAccount: yakklPrimaryAccount,  // If subaccount then it must be a valid primaryaccount else undefined
                data: {
                  extendedKey: ethWallet.extendedKey,
                  privateKey: ethWallet.privateKey,
                  publicKey: ethWallet.publicKey,
                  publicKeyUncompressed: ethWallet.signingKey.publicKey,
                  path: ethWallet.path ? ethWallet.path : dPath,
                  pathIndex: ethWallet.index,
                  fingerPrint: ethWallet.fingerprint,
                  parentFingerPrint: ethWallet.parentFingerprint,
                  chainCode: ethWallet.chainCode,
                  assignedTo: [],    // Who are the parties that have responsibility for this account
                },
                value: '0.0', 
                class: "Default",  // This is only used for enterprise like environments. It can be used for departments like 'Finance', 'Accounting', '<whatever>'
                level: 'L1',
                isSigner: true,
                avatar: '', // Default is identityicon but can be changed to user/account avatar
                tags: [$yakklCurrentlySelectedStore.shortcuts.networkName, 'sub'],
                includeInPortfolio: true,   // This only applys to the value in this primary account and not any of the derived accounts from this primary account
                urlExplorer: "https://etherscan.io/address/" + addressDerived,  
                connectedDomains: [], 
                createDate: currentDate,
                updateDate: currentDate,
              };

              let yakklAccountEnc = deepCopy(yakklAccount);
              await encryptData(yakklAccount.data, $yakklMiscStore).then(result => {
                yakklAccountEnc.data = result;
              });
              
              yakklPrimaryAccount.subAccounts.push(yakklAccountEnc);
              // Maybe verify profileIndex is valid
              yakklProfile.data.primaryAccounts[profileIndex-1] = yakklPrimaryAccount;

              setYakklPrimaryAccountsStorage(yakklProfile.data.primaryAccounts);  // sets the full list

              let yakklProfileEnc = deepCopy(yakklProfile);
              await encryptData(yakklProfile.data, $yakklMiscStore).then(result => {
                yakklProfileEnc.data = result;
              });

              await setYakklProfileStorage(yakklProfileEnc);

              derivedIndex++;
            };
          }

          showConfetti = true;
          goto(PATH_WELCOME);
        }
      }
    } catch (e) {
      error = true;
      errorValue = `Your Wallet did not initialize for the following reason: ${e}`;
      console.log(errorValue);
    }
  }


  const { form, errors, state, isValid, handleChange, handleSubmit } = createForm({
    initialValues: { 
      userName: "",
      password: "", 
      confirmPassword: "",
      secretPhrase: ""
    },
    validationSchema: yup.object().shape({
      userName: yup.string().required('Please enter your username'),
      password: yup
        .string()
        .required('Please enter your password. It must be at least 8 characters')
        .matches(
        /^(?=.*[A-Za-z])(?=.*\d)(?=.*[@$!%*#?&])[A-Za-z\d@$!%*#?&]{8,}$/,
        "Must Contain at least 8 Characters (12 Characters are best), One Uppercase, One Lowercase, One Number and one special case Character"
        ),
      confirmPassword: yup
        .string()
        .oneOf([yup.ref('password'), null], 'Passwords must match'),
    }),
    onSubmit: data => {
      try {
        elements = document.querySelectorAll("[data-id]");
        srp = "";
        if (elements) {
          elements.forEach(el => {
            srp += el.value + ' ';
          });
          data.secretPhrase = srp.trim();

          processSecretPhaseRecovery(data);
        } else {
          throw 'Your Secret Phrase does not seem to correct. Check the formatting. You can enter each word and it MUST BE IN ORDER -OR- paste the whole phrase after copying from your backup into any field.';
        }
      } catch(e) {
        errorValue = e;
        error = true;
        clearData(data);
      }
    }
  });

  function clearData(data) {
    $form.userName = data.userName = "";
    $form.password = data.password = "";
    $form.confirmPassword = data.confirmPassword = "";
    data.secretPhrase = "";
    elements = document.querySelectorAll("[data-id]");
    if (elements) {
      elements.forEach(el => {
        el.value = "";
      });
    }
  }


  function hideShowWords() {
    let count = parseInt(selected);

    let element;
    let element_text;

    for (let wordCount=13; wordCount <= 24; wordCount++){
      element_text = document.getElementById(`word_text_${wordCount}`);
      element = document.getElementById(`word_${wordCount}`);

      // Show and then toggle - this covers fringe cases
      element_text.style.display = "block";
      element.style.display = "block";
    }

    for (let wordCount=24; wordCount > count; wordCount--) {
      element_text = document.getElementById(`word_text_${wordCount}`);
      element = document.getElementById(`word_${wordCount}`);

      if (element_text.style.display === "none") {
          element_text.style.display = "block";
      } else {
          element_text.style.display = "none";
      }
      
      if (element.style.display === "none") {
          element.style.display = "block";
      } else {
          element.style.display = "none";
      }
    }
    
    switch (count) {
      case 12:
        mtop = '-mt-[9rem]';
        break;
      case 15:
        mtop = '-mt-[6.5rem]';
        break;
      case 18:
        mtop = '-mt-[4.25rem]';
        break;
      case 21:
        mtop = '-mt-[2.5rem]';
        break;
      case 24: // Our default
        mtop = '';
        break;
      default:
        mtop = '';
        break;
    }
  }

  function toggleVisability() {
    let x = document.getElementById("password");
    if (x && x.type) {
      if (x.type === "password") {
        x.type = "text";
      } else {
        x.type = "password";
      }
    }
    // make better
    x = document.getElementById("confirmPassword");
    if (x && x.type) {
      if (x.type === "password") {
        x.type = "text";
      } else {
        x.type = "password";
      }
    }
  }

  function toggleWordsVisability() {
    elements = document.querySelectorAll("[data-id]");
    elements.forEach(el => {
      if (el.type === "password") {
        el.type = "text";
      } else {
        el.type = "password";
      }
    });
  }

  function handlePaste(e){
    e.preventDefault();
  }

  onMount( () => {
    try {
      hideShowWords();
      // This applies to the whole page which may not be ideal but works if only pasting the SRP
      // TBD - may want to look at which field the paste event originated from and go from there instad of 
      // overriding the entire list on each paste.
      document.addEventListener("paste", function(e) {
        // if the target is a text input
        if (e.target.type === "text") {
          let data = e.clipboardData.getData('Text');
          // split clipboard text into single words
          data = data.split(' ');
          // find all other text inputs
          [].forEach.call(document.querySelectorAll("[data-id]"), (node, index) => {
              // And set input value to the relative character
            node.value = data[index-1];
          });
        } 
      });

      // Remove later after testing...

			// if (!$yakklCurrentlySelectedStore.shortcuts.providerObject) {
			// 	let providerObject = setProvider($yakklCurrentlySelectedStore.shortcuts.provider, $yakklCurrentlySelectedStore.shortcuts.networkName, $yakklCurrentlySelectedStore.shortcuts.networkChainId,  $yakklCurrentlySelectedStore.data.providerKey);
			// 	if (providerObject === null) {
			// 		// Try the mainnet instead
			// 		$yakklCurrentlySelectedStore.shortcuts.networkTypeName = 'Mainnet';
			// 		providerObject = setProvider($yakklCurrentlySelectedStore.shortcuts.provider, $yakklCurrentlySelectedStore.shortcuts.networkName, $yakklCurrentlySelectedStore.shortcuts.networkChainId,  $yakklCurrentlySelectedStore.data.providerKey);
			// 	}
			// 	$yakklCurrentlySelectedStore.shortcuts.providerObject = providerObject;
			// }

			// provider = {
			// 	name: PROVIDERS.ALCHEMY,
			// 	chainId: toHex($yakklCurrentlySelectedStore.shortcuts.networkChainId),
			// 	privateKey: null,
			// };

    } catch (e) {
      console.log(e);
      errorValue = e;
      error = true;
    }
  });
</script>

{#if showConfetti}
<Confetti />
{/if}

<Modal bind:open={error}>
    <div class="text-center">
        <svg aria-hidden="true" class="mx-auto mb-4 w-14 h-14 text-gray-400 dark:text-gray-200" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
        <h3 class="mb-5 text-lg font-normal text-gray-500 dark:text-gray-400"><span class="font-bold">{msgType}</span>{errorValue}</h3>
        <Button color='red'>Close</Button>
    </div>
</Modal>
  
<div class="flex flex-col h-full w-full relative justify-center left-0 z-5 text-base-content bg-base-100"> 
    <Back defaultClass="-left-3 -top-2 absolute" href=''/>

    <div class="">
        <span class="block w-full px-1 text-xl font-extrabold border-none text-center">Import Secret Recovery Phrase</span>
    </div>

    <hr class="mb-3"/>

    <p class="ml-5 mr-5 p-2 text-small border-2 border-red-200 bg-red-50 text-red-900 rounded-md" aria-label="Private Key warning">
        Please be careful! <strong>This Secret Recovery Phrase is important!</strong>. 
        A bad actor could take the content of your wallet if they have access to your Private Key or Secret Recovery Phrase!
        This process will restore all of the accounts that were created by YAKKL only! If you imported existing private keys from another wallet then you will need to do so again.
    </p>

    <div class="pt-2 ml-5 mr-5 text-base-content">
        <div class="h-[650px]">
            <form class="px-5" on:submit|preventDefault={handleSubmit}>
                <div class="my-1">
                    <select id="words" bind:value={selected} on:change="{hideShowWords}"  class="block w-full px-4 md:py-2 py-1 text-xl font-normal text-base-content bg-clip-padding border border-solid border-gray-300 rounded-md ">
                        <option value="12">12 Word Secret Phrase</option>
                        <option value="15">15 Word Secret Phrase</option>
                        <option value="18">18 Word Secret Phrase</option>
                        <option value="21">21 Word Secret Phrase</option>
                        <option value="24" selected>24 Word Secret Phrase</option>
                    </select>
                    <input
                        id="userName"
                        class="block w-full px-4 md:py-2 py-1 mt-1 text-xl font-normal input input-bordered input-primary"
                        placeholder="Username"
                        bind:value="{$form.userName}"
                        on:change="{handleChange}"
                    />
                    {#if $errors.userName}
                    <small class="text-red-800 animate-pulse">{$errors.userName}</small>
                    {/if}
                    <input
                        id="password"
                        type="password"
                        class="block w-full px-4 md:py-2 py-1 mt-4 text-xl font-normal input input-bordered input-primary"
                        placeholder="Password"
                        autocomplete="off"
                        bind:value="{$form.password}"
                        on:change="{handleChange}"
                        required
                    />
                    {#if $errors.password}
                    <small class="text-red-800 animate-pulse">{$errors.password}</small>
                    {/if}
                    <div class="flex ml-1">
                        <div>
                          <div class="form-check">
                            <input id="seePassword" on:click="{toggleVisability}" class="form-check-input appearance-none h-4 w-4 checkbox checkbox-primary float-left mr-2 cursor-pointer" type="checkbox" value="">
                            <label class="form-check-label text-sm inline-block label-text" for="seePassword">
                              Show Password
                            </label>
                          </div>
                        </div>
                    </div>
                    <div class="flex ml-1">
                      <div>
                        <div class="form-check">
                          <input id="subaccounts" on:click="{subAccounts = !subAccounts}" class="form-check-input appearance-none h-4 w-4 checkbox checkbox-primary float-left mr-2 cursor-pointer" type="checkbox" value="" checked>
                          <label class="form-check-label text-sm inline-block label-text" for="subaccounts">
                            Recover Subaccounts (derived from the Secret Recovery Phrase)
                          </label>
                        </div>
                      </div>
                  </div>
              </div>
                <hr/>
                <div class="flex ml-1 mt-4">
                    <div>
                      <div class="form-check">
                        <input id="seeWords" on:click="{toggleWordsVisability}" class="form-check-input appearance-none h-4 w-4 checkbox checkbox-primary float-left mr-2 cursor-pointer" type="checkbox" value="">
                        <label class="form-check-label text-sm inline-block label-text" for="seePassword">
                          Show Secret Recovery Phrase Words
                        </label>
                      </div>
                    </div>
                </div>
                <div class="mt-4">
                    {#each  Array(24) as _, index (index)}
                    <div class="flex space-x-2 mb-3">
                        <span id="word_text_{index+1}" class="inline-block w-[5%] h-[35px] pt-1 text-md justify-center text-base-content">{index+1}.</span>
                        <input 
                            type="password" 
                            class="input input-bordered input-primary w-full"
                            id="word_{index+1}"
                            data-id="{index+1}"
                            aria-label="Word {index+1}"
                            autocomplete="off"
                            on:paste={handlePaste}
                        />
                    </div>
                    {/each}
                </div>

                <div class="{mtop} mb-20">
                    <div class="flex space-x-2 justify-center">
                        <!-- svelte-ignore a11y-click-events-have-key-events -->
                        <!-- svelte-ignore a11y-interactive-supports-focus -->
                        <button on:click={() => goto(PATH_WELCOME)} 
                            aria-label="Cancel"
                            class="btn-sm btn-accent uppercase rounded-full">
                            Cancel
                        </button>
                        <button 
                            type="submit"
                            id="recover"
                            on:click="{handleSubmit}"
                            class="btn-sm btn-primary uppercase rounded-full ml-2"
                            aria-label="Confirm">
                            Recover
                        </button>
                    </div>
                </div>   
            </form>            
        </div>

    </div>
   
</div>

  
